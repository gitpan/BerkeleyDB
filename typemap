# typemap for Perl 5 interface to Berkeley DB version 2
#
# SCCS: %I%, %G%     
#
# written by Paul Marquess <Paul.Marquess@btinternet.com>
#
#################################### DB SECTION
#
# 

void *			T_PV
u_int			T_U_INT
u_int32_t		T_U_INT
const char * 		T_PV_NULL
PV_or_NULL		T_PV_NULL
IO_or_NULL		T_IO_NULL
BerkeleyDB		T_PTROBJ
BerkeleyDB::Common	T_PTROBJ_SELF
BerkeleyDB::Hash	T_PTROBJ_SELF
BerkeleyDB::Btree	T_PTROBJ_SELF
BerkeleyDB::Recno	T_PTROBJ_SELF
BerkeleyDB::Cursor	T_PTROBJ
BerkeleyDB::TxnMgr	T_PTROBJ
BerkeleyDB::Txn		T_PTROBJ
BerkeleyDB::Log		T_PTROBJ
BerkeleyDB::Lock	T_PTROBJ
BerkeleyDB::Env		T_PTROBJ_SELF
BerkeleyDB::Env::Inner	T_INNER
BerkeleyDB::Common::Inner	T_INNER
BerkeleyDB::Txn::Inner	T_INNER
BerkeleyDB::TxnMgr::Inner	T_INNER
# BerkeleyDB__Env 	T_PTR
DBT			T_dbtdatum
DBT_B			T_dbtdatum_btree
DBTKEY			T_dbtkeydatum
DBTKEY_B		T_dbtkeydatum_btree
DBTYPE			T_U_INT
DualType		T_DUAL
BerkeleyDB_type *	T_IV
BerkeleyDB_ENV_type *	T_IV
BerkeleyDB_TxnMgr_type * T_IV
BerkeleyDB_Txn_type *	T_IV
BerkeleyDB__Cursor_type * T_IV
DB *			T_IV

INPUT

T_U_INT
        $var = SvUV($arg)

T_SV_REF_NULL
	if ($arg == &sv_undef)
	    $var = NULL ;
        else if (sv_derived_from($arg, \"${ntype}\")) {
            IV tmp = SvIV((SV *)GetInternalObject($arg));
            $var =  ($type) tmp;
        }
        else
            croak(\"$var is not of type ${ntype}\")

T_HV_REF_NULL
	if ($arg == &sv_undef)
	    $var = NULL ;
        else if (sv_derived_from($arg, \"${ntype}\")) {
            HV * hv = (HV *)GetInternalObject($arg);
            SV ** svp = hv_fetch(hv, \"db\", 2, FALSE);
            IV tmp = SvIV(*svp);
            $var =  ($type) tmp;
        }
        else
            croak(\"$var is not of type ${ntype}\")

T_HV_REF
        if (sv_derived_from($arg, \"${ntype}\")) {
            HV * hv = (HV *)GetInternalObject($arg);
            SV ** svp = hv_fetch(hv, \"db\", 2, FALSE);
            IV tmp = SvIV(*svp);
            $var =  ($type) tmp;
        }
        else
            croak(\"$var is not of type ${ntype}\")


T_P_REF
        if (sv_derived_from($arg, \"${ntype}\")) {
            IV tmp = SvIV((SV*)SvRV($arg));
            $var = ($type) tmp;
        }
        else
            croak(\"$var is not of type ${ntype}\")


T_INNER
	{
	    HV * hv = (HV *)SvRV($arg);
            SV ** svp = hv_fetch(hv, \"db\", 2, FALSE);
            IV tmp = SvIV(*svp);
            $var =  ($type) tmp;
	}

T_PV_NULL
	if ($arg == &sv_undef)
	    $var = NULL ;
	else {
            $var = ($type)SvPV($arg,na) ;
	    if (na == 0)
		$var = NULL ;
	}

T_IO_NULL
	if ($arg == &sv_undef)
	    $var = NULL ; 
	else 
            $var = IoOFP(sv_2io($arg))

T_PTROBJ_NULL
	if ($arg == &sv_undef)
	    $var = NULL ;
        else if (sv_derived_from($arg, \"${ntype}\")) {
            IV tmp = SvIV((SV*)SvRV($arg));
            $var = ($type) tmp;
        }
        else
            croak(\"$var is not of type ${ntype}\")

T_PTROBJ_SELF
	if ($arg == &sv_undef)
	    $var = NULL ;
        else if (sv_derived_from($arg, \"${ntype}\")) {
            IV tmp = SvIV((SV*)SvRV($arg));
            $var = ($type) tmp;
        }
        else
            croak(\"$var is not of type ${ntype}\")

T_dbtkeydatum
	ckFilter($arg, writeKey, \"writeKey\");
	if (db->type == DB_RECNO) {
	    Value = GetRecnoKey(db, SvIV($arg)) ; 
	    $var.data = & Value; 
	    $var.size = (int)sizeof(db_recno_t);
	}
	else {
	    $var.data = SvPV($arg, na);
	    $var.size = (int)na;
	}
	$var.flags = 0 ;

T_dbtkeydatum_btree
	ckFilter($arg, writeKey, \"writeKey\");
	if (db->type == DB_RECNO || 
		(db->type == DB_BTREE && flagSet(DB_SET_RECNO))) {
	    Value = GetRecnoKey(db, SvIV($arg)) ; 
	    $var.data = & Value; 
	    $var.size = (int)sizeof(db_recno_t);
	}
	else {
	    $var.data = SvPV($arg, na);
	    $var.size = (int)na;
	}
	$var.flags = 0 ;

T_dbtdatum
	ckFilter($arg, writeValue, \"writeValue\");
	$var.data = SvPV($arg, na);
	$var.size = (int)na;
  	$var.flags = db->partial ;
    	$var.dlen  = db->dlen ;
	$var.doff  = db->doff ;
	
T_dbtdatum_btree
	ckFilter($arg, writeValue, \"writeValue\");
	$var.data = SvPV($arg, na);
	$var.size = (int)na;
  	$var.flags = db->partial ;
    	$var.dlen  = db->dlen ;
	$var.doff  = db->doff ;
	

OUTPUT

T_SV_REF_NULL
	sv_setiv($arg, (IV)$var);

T_HV_REF_NULL
	sv_setiv($arg, (IV)$var);

T_HV_REF
	sv_setiv($arg, (IV)$var);

T_P_REF
	sv_setiv($arg, (IV)$var);

T_DUAL
	setDUALerrno($arg, $var) ;

T_U_INT
        sv_setuv($arg, (UV)$var);

T_PV_NULL
        sv_setpv((SV*)$arg, $var);

T_dbtkeydatum_btree
	OutputKey_B($arg, $var)
T_dbtkeydatum
	OutputKey($arg, $var)
T_dbtdatum
	OutputValue($arg, $var)
T_dbtdatum_btree
	OutputValue_B($arg, $var)

T_PTROBJ_NULL
        sv_setref_pv($arg, \"${ntype}\", (void*)$var);

T_PTROBJ_SELF
        sv_setref_pv($arg, self, (void*)$var);
